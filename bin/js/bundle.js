var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
var config = {
    debug: false,
    version: '1.0',
    release: 10
};
exports.default = config;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
				value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**This class is automatically generated by LayaAirIDE, please do not make any modifications. */


var _PassResultDialog = require("./gamescripts/dialog/PassResultDialog");

var _PassResultDialog2 = _interopRequireDefault(_PassResultDialog);

var _GameView = require("./gamescripts/GameView");

var _GameView2 = _interopRequireDefault(_GameView);

var _MPBar = require("./gamescripts/prefab/MPBar");

var _MPBar2 = _interopRequireDefault(_MPBar);

var _HPBar = require("./gamescripts/prefab/HPBar");

var _HPBar2 = _interopRequireDefault(_HPBar);

var _Dodge = require("./gamescripts/prefab/Dodge");

var _Dodge2 = _interopRequireDefault(_Dodge);

var _GameControl = require("./gamescripts/GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

var _GameBanner = require("./gamescripts/prefab/GameBanner");

var _GameBanner2 = _interopRequireDefault(_GameBanner);

var _Skill = require("./gamescripts/prefab/Skill");

var _Skill2 = _interopRequireDefault(_Skill);

var _Player = require("./gamescripts/prefab/Player");

var _Player2 = _interopRequireDefault(_Player);

var _LoadingView = require("./scripts/common/Loading/LoadingView");

var _LoadingView2 = _interopRequireDefault(_LoadingView);

var _LoadingControl = require("./scripts/common/Loading/LoadingControl");

var _LoadingControl2 = _interopRequireDefault(_LoadingControl);

var _HomeControl = require("./scripts/common/HomeControl");

var _HomeControl2 = _interopRequireDefault(_HomeControl);

var _Weapon = require("./gamescripts/prefab/Weapon");

var _Weapon2 = _interopRequireDefault(_Weapon);

var _WeaponBar = require("./gamescripts/prefab/WeaponBar");

var _WeaponBar2 = _interopRequireDefault(_WeaponBar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GameConfig = function () {
				function GameConfig() {
								_classCallCheck(this, GameConfig);
				}

				_createClass(GameConfig, null, [{
								key: "init",
								value: function init() {
												//注册Script或者Runtime引用
												var reg = Laya.ClassUtils.regClass;
												reg("gamescripts/dialog/PassResultDialog.js", _PassResultDialog2.default);
												reg("gamescripts/GameView.js", _GameView2.default);
												reg("gamescripts/prefab/MPBar.js", _MPBar2.default);
												reg("gamescripts/prefab/HPBar.js", _HPBar2.default);
												reg("gamescripts/prefab/Dodge.js", _Dodge2.default);
												reg("gamescripts/GameControl.js", _GameControl2.default);
												reg("gamescripts/prefab/GameBanner.js", _GameBanner2.default);
												reg("gamescripts/prefab/Skill.js", _Skill2.default);
												reg("gamescripts/prefab/Player.js", _Player2.default);
												reg("scripts/common/Loading/LoadingView.js", _LoadingView2.default);
												reg("scripts/common/Loading/LoadingControl.js", _LoadingControl2.default);
												reg("scripts/common/HomeControl.js", _HomeControl2.default);
												reg("gamescripts/prefab/Weapon.js", _Weapon2.default);
												reg("gamescripts/prefab/WeaponBar.js", _WeaponBar2.default);
								}
				}]);

				return GameConfig;
}();

exports.default = GameConfig;

GameConfig.width = 1134;
GameConfig.height = 750;
GameConfig.scaleMode = "fixedwidth";
GameConfig.screenMode = "horizontal";
GameConfig.alignV = "top";
GameConfig.alignH = "left";
GameConfig.startScene = "gamescenes/dialog/PassResult.scene";
GameConfig.sceneRoot = "";
GameConfig.debug = false;
GameConfig.stat = false;
GameConfig.physicsDebug = false;
GameConfig.exportSceneToJson = true;

GameConfig.init();

},{"./gamescripts/GameControl":4,"./gamescripts/GameView":5,"./gamescripts/dialog/PassResultDialog":8,"./gamescripts/prefab/Dodge":9,"./gamescripts/prefab/GameBanner":10,"./gamescripts/prefab/HPBar":11,"./gamescripts/prefab/MPBar":12,"./gamescripts/prefab/Player":13,"./gamescripts/prefab/Skill":14,"./gamescripts/prefab/Weapon":15,"./gamescripts/prefab/WeaponBar":16,"./scripts/common/HomeControl":18,"./scripts/common/Loading/LoadingControl":19,"./scripts/common/Loading/LoadingView":20}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Main = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _GameConfig = require("./GameConfig");

var _GameConfig2 = _interopRequireDefault(_GameConfig);

var _Config = require("./Config");

var _Config2 = _interopRequireDefault(_Config);

var _GameMain2 = require("./scripts/common/GameMain");

var _GameMain3 = _interopRequireDefault(_GameMain2);

var _HeroConfig = require("./gamescripts/config/HeroConfig");

var _HeroConfig2 = _interopRequireDefault(_HeroConfig);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Main = exports.Main = function (_GameMain) {
	_inherits(Main, _GameMain);

	function Main() {
		_classCallCheck(this, Main);

		var params = {
			gameId: 1006,
			// baseURL: "https://wxapi.xingqiu123.com/ServiceCore/",
			baseURL: "https://juedi001test.goxiaochengxu.cn/ServiceCore/",
			//	baseURL:"https://juedi001test.goxiaochengxu.cn/ServiceCore/",
			zone: "cate",
			showStat: false,
			showDebugTool: true,
			userId: 11012, //151693, 109638
			offerId: "1450014295",
			version: _Config2.default.version,
			rankingType: PaoYa.RankingType.WIN,
			release: _Config2.default.release,
			//ignoreCmds: [],
			debug: true,
			ignoreCmds: ['defeated', 'message'],
			showBannerAdWhenDialogPopup: false,
			adUnitId: 'adunit-7860aaf8ed04aeb2',
			bannerUnitId: 'adunit-4bec7f17587df319', //bannerID
			portrait: "landscape",
			loadNetworkRes: false,
			is_config: 0
		};
		return _possibleConstructorReturn(this, (Main.__proto__ || Object.getPrototypeOf(Main)).call(this, params));
	}

	_createClass(Main, [{
		key: "setupConfig",
		value: function setupConfig() {
			//Laya.MouseManager.enabled=false;
			Laya.MouseManager.multiTouchEnabled = false; //关闭多点触控
			_get(Main.prototype.__proto__ || Object.getPrototypeOf(Main.prototype), "setupConfig", this).call(this);
			//分享地址
			PaoYa.ShareManager.imageURL = "https://res.xingqiu123.com/1028/share/share.jpg";
			PaoYa.DataCenter.GAMEPREPARE = null;

			if (typeof wx != 'undefined' || Laya.Render.isConchApp) {
				// console.log=function(){};
				wx.onMemoryWarning(function () {
					console.error('内存不足');
				});
			}
			/* 	
   	PaoYa.SoundManager.onHideHandler = function () {
   		Laya.SoundManager.stopAll();
   	}
   	PaoYa.SoundManager.onShowHandler = function () {
   		SoundManager.playMusic("mainBgm");
   	}
   	PaoYa.SoundManager.onAudioInterruptionBeginHandler = function () {
   		Laya.SoundManager.stopAll();
   	}
   	PaoYa.SoundManager.onAudioInterruptionEndHandler = function () {
   		Laya.SoundManager.playMusic(SoundManager.currentUrl, 0);
   	}
   	SoundManager.playMusic("mainBgm"); */
			_HeroConfig2.default.loadAllSpine();
		}
		/**此处返回游戏需要提前加载的资源，必须返回一个数组 */

	}, {
		key: "setupGameRes",
		value: function setupGameRes() {
			var list = ['res/atlas/remote/game.atlas', 'res/atlas/remote/weapons.atlas', 'spine/npc/npc_7.png', 'spine/npc/npc_7.sk', 'spine/hero/hero_1.png', 'spine/hero/hero_1.sk', 'spine/freeze/freeze.png', 'spine/freeze/freeze.sk',
			/* 动效animation资源 */
			'res/atlas/remote/debuff_dizzy.atlas', 'res/atlas/remote/debuff_palsy.atlas', 'res/atlas/remote/debuff_poison.atlas', 'res/atlas/remote/injured.atlas', 'res/atlas/remote/recover_blood.atlas', 'res/atlas/remote/recover_power.atlas', 'res/atlas/remote/trigger_skill.atlas', 'res/atlas/remote/warn_arms.atlas', //cd发光效果
			'res/atlas/remote/hero1_skill2.atlas'];
			return list;
		}
	}, {
		key: "onShareAppMessage",
		value: function onShareAppMessage() {
			return {
				title: PaoYa.DataCenter.config.game.share_list.randomItem,
				imageUrl: PaoYa.DataCenter.CDNURL + PaoYa.DataCenter.config.game.share_img.randomItem,
				query: ""
			};
		}
	}]);

	return Main;
}(_GameMain3.default);
//激活启动类


new Main();
console.log = function () {};
console.warn = function () {};
console.error = function () {};

},{"./Config":1,"./GameConfig":2,"./gamescripts/config/HeroConfig":7,"./scripts/common/GameMain":17}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Weapon = require('./prefab/Weapon');

var _Weapon2 = _interopRequireDefault(_Weapon);

var _WeaponBar = require('./prefab/WeaponBar');

var _WeaponBar2 = _interopRequireDefault(_WeaponBar);

var _Player = require('./prefab/Player');

var _Player2 = _interopRequireDefault(_Player);

var _MPBar = require('./prefab/MPBar');

var _MPBar2 = _interopRequireDefault(_MPBar);

var _HPBar = require('./prefab/HPBar');

var _HPBar2 = _interopRequireDefault(_HPBar);

var _WeaponManager = require('./WeaponManager');

var _WeaponManager2 = _interopRequireDefault(_WeaponManager);

var _Skill = require('./prefab/Skill');

var _Skill2 = _interopRequireDefault(_Skill);

var _Dodge = require('./prefab/Dodge');

var _Dodge2 = _interopRequireDefault(_Dodge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameControl = function (_PaoYa$Component) {
    _inherits(GameControl, _PaoYa$Component);

    /** @prop {name:weapon,tips:"武器预制体对象",type:Prefab}*/
    /** @prop {name:weaponBar,tips:"武器预制体对象",type:Prefab}*/
    /** @prop {name:player,tips:"人物预制体对象",type:Prefab} */
    /** @prop {name:selfHP,tips:'自己的血条',type:Node}*/
    /** @prop {name:selfMP,tips:'自己的体力',type:Node}*/
    /** @prop {name:otherHP,tips:'对方的血条',type:Node}*/
    /** @prop {name:otherMP,tips:'对方的体力',type:Node}*/

    function GameControl() {
        _classCallCheck(this, GameControl);

        var _this = _possibleConstructorReturn(this, (GameControl.__proto__ || Object.getPrototypeOf(GameControl)).call(this));

        GameControl.instance = _this;
        Laya.MouseManager.multiTouchEnabled = false;
        return _this;
    }

    _createClass(GameControl, [{
        key: 'onAwake',
        value: function onAwake() {
            Laya.MouseManager.enabled = true;

            this.params = this.owner.params;
            //暂定
            this.gameType = "pass";
            this.passNum = 1;

            this.weaponList = this.params.weaponList;
            this.robotWeaponList = this.params.robotWeaponList;
            this.dealParams(this.weaponList);
            this.dealParams(this.robotWeaponList);

            this.selfMultiMP = 1; //兵器造成的内力消耗倍数
            this.otherMultiMP = 1; //兵器造成的内力消耗倍数
            this.weaponsBarArr = []; //存放兵器操作Bar;提供全局暂停和恢复CD功能；

            //暂时这么用;可能要用全局状态管理器
            this.selfWeapons = [];
            this.otherWeapons = [];
            this.dodgeComp = this.owner.dodge.getComponent(_Dodge2.default);
            this.initWeaponsBar();
            this.initPlayer(true);
            this.initPlayer(false);
            this.initSkill();
            this.owner.setInfo({
                name: '阿强',
                icon: 'remote/game/avstar_1.png'
            }, true);
            this.owner.setInfo({
                name: '阿强',
                icon: 'remote/game/avstar_1.png'
            }, false);
            Laya.timer.once(5000, this, function () {
                // Laya.timer.once(1000,this,this.startSelect); 

            });
            //机器人开始

            //画出三条运动轨迹，便于调试
            this.curvature = 0.0008;
            this.drawParabola();
            this.curvature = 0.0015;
            this.drawParabola();
            this.curvature = 0.0025;
            this.drawParabola();
        }
        //游戏重新开始

    }, {
        key: 'restart',
        value: function restart() {}
        /*   this.startPos = {
                x: 340,
                y: 450
              }
              this.endPos = {
                x: 960,
                y: 450
              } */

    }, {
        key: 'drawParabola',
        value: function drawParabola() {
            var space = 5;
            var pathArr = [];
            this.startPos = {
                x: 180,
                y: 450
            };
            this.endPos = {
                x: 1150,
                y: 450
            };
            pathArr.push(["moveTo", 0, 0]);

            // X轴Y轴的偏移总量
            this.driftX = this.endPos.x - this.startPos.x;
            this.driftY = this.endPos.y - this.startPos.y;
            this.b = (this.driftY - this.curvature * this.driftX * this.driftX) / this.driftX;
            for (var i = 5; i <= this.driftX; i += space) {
                var x = i;
                var y = Math.floor(this.curvature * x * x + this.b * x);
                pathArr.push(["lineTo", x, y]);
            }
            pathArr.push(["closePath"]);
            // this.owner.spDraw.graphics.clear();
            this.owner.spDraw.graphics.drawPath(this.startPos.x, this.startPos.y, pathArr, null, {
                strokeStyle: "#ff0000",
                lineWidth: 2,
                lineCap: "round"
            });
            //this.owner.spDraw.graphics.drawPath(340,450,)
        }
    }, {
        key: 'dealParams',
        value: function dealParams(weaponList) {
            for (var i = 0; i < weaponList.length; i++) {
                var weapon = weaponList[i];
                var weaponSkills = weapon['skills'];
                for (var j = 0; j < weaponSkills.length; j++) {
                    if (weaponSkills[j].skillType == 1) {
                        weapon.activeSkill = JSON.parse(JSON.stringify(weaponSkills[j]));
                    }
                }
            }
        }
    }, {
        key: 'onClick',
        value: function onClick(e) {
            switch (e.target.name) {

                case 'skill1':
                    this.skillWithWeapon(true);
                    break;
                case 'skill2':
                    this.skillWithoutWeapon(true);
                    break;

            }
        }
    }, {
        key: 'onEnable',
        value: function onEnable() {
            this.onNotification(_WeaponBar2.default.CLICK, this, this.weaponBarClickHandler);
        }
        //初始化双方兵器库

    }, {
        key: 'initWeaponsBar',
        value: function initWeaponsBar() {
            var owner = this.owner,
                boxWeapon = owner.boxWeapon;

            for (var i = 0, len = this.weaponList.length; i < len; i++) {
                //暂时
                // if()
                var weaponBar = this.weaponBar.create.call(this.weaponBar);
                var weaponBarComp = weaponBar.getComponent(_WeaponBar2.default);
                weaponBarComp.params = this.weaponList[i];
                weaponBarComp.isSelf = true;
                weaponBarComp.index = i;
                this.weaponsBarArr.push(weaponBarComp);
                boxWeapon.addChild(weaponBar);
            }
            //初始化机器人的兵器
            //console.log(this.weaponsBarArr);
            this.weaponManager = new _WeaponManager2.default(this.robotWeaponList);
        }
    }, {
        key: 'initPlayer',
        value: function initPlayer(isSelf) {
            var name = isSelf ? 'self' : 'other';
            var role = isSelf ? 'role' : 'robotRole';
            var player = Laya.Pool.getItemByCreateFun('player', this.player.create, this.player);
            var spCollide = this.owner[name + 'Collide'];
            var spX = spCollide.x,
                spY = spCollide.y,
                spW = spCollide.width,
                spH = spCollide.height;

            //let playerScr=player.getComponent(Player)
            var component = player.getComponent(_Player2.default);
            component.isSelf = isSelf;
            component.attr = this.params[role];
            component.activeSkills = [];
            //把人物主动技能挑选出来
            for (var i = 0, len = this.params[role].skills.length; i < len; i++) {
                if (this.params[role].skills[i].skillType == 1) {
                    component.activeSkills.push(this.params[role].skills[i]);
                }
            }
            console.error('人物技能');
            console.error(component.activeSkills);

            //component.attr.skillWeapon.params={};
            if (component.attr.skillWeapon) {
                component.attr.skillWeapon.activeSkill = component.attr.skillWeapon.skills[0];
            }
            console.error(component.attr.skillWeapon);
            component.MPComp = this[name + 'MP'].getComponent(_MPBar2.default);
            component.HPComp = this[name + 'HP'].getComponent(_HPBar2.default);
            component.MPComp.initBar(this.params[role].roleMp);
            component.HPComp.initBar(this.params[role].roleHp);
            component.isSelf = isSelf;
            if (isSelf) {
                player.pos(220, 560);
            } else {
                player.pos(1120, 560);
                player.scaleX = -1;
            }
            component.collidePoint = [{
                x: spX,
                y: spY
            }, {
                x: spX + spW,
                y: spY
            }, {
                x: spX + spW,
                y: spY + spH
            }, {
                x: spX,
                y: spY + spH
            }];
            this.owner.addChild(player);
            this[name + 'Player'] = {
                node: player,
                comp: component
            };
        }
    }, {
        key: 'initSkill',
        value: function initSkill() {
            var owner = this.owner;
            var time1 = this.selfPlayer.comp.activeSkills[0].skillCd * 1000;
            var time2 = this.selfPlayer.comp.activeSkills[1].skillCd * 1000;
            this.skillScrO = owner.skill1.getComponent(_Skill2.default);
            this.skillScrT = owner.skill2.getComponent(_Skill2.default);
            this.skillScrO.initCdTime(time1);
            this.skillScrT.initCdTime(time2);
            /* owenr.skill1.index=1;
            owenr.skill2.index=2; */
            // this.skillScrO.
        }
    }, {
        key: 'skillWithWeapon',
        value: function skillWithWeapon(isSelf) {
            var name = isSelf ? 'self' : 'other';
            var roleComp = this[name + 'Player'].comp,
                skillWeapon = JSON.parse(JSON.stringify(roleComp.attr.skillWeapon));
            var originMP = roleComp.MPComp.originMP;
            var consumeMP = skillWeapon.weaponConsume * originMP;
            if (this[name + 'Player'].comp.MPComp.curMP < consumeMP) {
                console.warn(name + 'Player' + "__体力不足");
                return;
            }

            skillWeapon.isSelf = isSelf;
            this[name + 'Player'].comp.MPComp.changeMP(-consumeMP);
            skillWeapon.skillEffect = true;
            switch (skillWeapon.activeSkill.skillId) {
                case 88:
                    var addCritProb = skillWeapon.activeSkill.skillConfig.critProb;
                    this[name + 'Player'].comp.attr.calcCritProb = this[name + 'Player'].comp.attr.roleCritProb + addCritProb;
                    break;
                case 89:
                    break;
                case 90:
                    break;
            }

            this.weaponLaunch(skillWeapon);
        }
    }, {
        key: 'skillWithoutWeapon',
        value: function skillWithoutWeapon(isSelf) {
            var _this2 = this;

            var name = isSelf ? 'self' : 'other';
            var skillInfo = this[name + 'Player'].comp.activeSkills[1];
            switch (skillInfo.skillId) {
                case 33:
                    this.allWeaponsUnfreeze(skillInfo);
                    break;
                case 36:
                    var t = skillInfo.skillConfig.time,
                        perMP = skillInfo.skillConfig.recoverMp,
                        originHP = this[name + 'Player'].comp.HPComp.originHP,
                        resumeHP = skillInfo.skillConfig.recoverHp;
                    this[name + 'Player'].comp.changePerMp(t, perMP);
                    this[name + 'Player'].comp.HPComp.changeHP(originHP * resumeHP);
                    break;
                case 39:
                    /* this[name+'Player'].comp.changePerMp(); */
                    this[name + 'MultiMP'] = skillInfo.skillConfig.consumeMp;
                    console.error('内力消耗倍数:', skillInfo.skillConfig.consumeMp);
                    Laya.timer.once(skillInfo.skillConfig.time * 1000, this, function () {
                        console.error('内力消耗倍数恢复:');
                        _this2[name + 'MultiMP'] = 1;
                    });
                    break;
                case 45:
                    break;
            }
        }
    }, {
        key: 'allWeaponsUnfreeze',
        value: function allWeaponsUnfreeze(skillInfo) {
            var _this3 = this;

            var time = skillInfo.skillConfig.time * 1000;
            this.weaponsBarArr.forEach(function (weaponBarComp) {
                weaponBarComp.endCD(); //探讨要不要
                weaponBarComp.setCdTime(0);
            });

            Laya.timer.once(time, this, function () {
                _this3.weaponsBarArr.forEach(function (weaponBarComp) {
                    weaponBarComp.setCdTime(weaponBarComp.originCdTime);
                });
            });
        }
    }, {
        key: 'startSelect',
        value: function startSelect() {
            var sWeapon = this.weaponManager.seletedWeapon();
            var curMp = this.otherPlayer.comp.MPComp.curMP;
            if (curMp >= sWeapon.params.weaponConsume) {
                sWeapon.isSelf = false;
                sWeapon.selectedHandler();
                this.weaponBarClickHandler(sWeapon);
                Laya.timer.once(5000, this, this.startSelect);
            } else {
                Laya.timer.once(500, this, this.startSelect);
            }
        }
        //兵器点击后我方表现

    }, {
        key: 'weaponBarClickHandler',
        value: function weaponBarClickHandler(targetComp) {
            //体力不够
            var name = targetComp.isSelf ? 'self' : 'other';
            var consumeMP = targetComp.weaponConsume;
            if (this[name + 'Player'].comp.MPComp.curMP < consumeMP) {
                console.warn(name + 'Player' + "__体力不足");
                //展示内力不足文字提示
                return;
            }

            this[name + 'Player'].comp.MPComp.changeMP(-consumeMP * this[name + 'MultiMP']);
            //人物表现
            if (this.isSelf) {
                console.error('用户发射武器........');
            }
            this[name + 'Player'].comp.attackEffect();
            this[name + 'Player'].comp.attr.calcCritProb = this[name + 'Player'].comp.attr.roleCritProb;
            //判断是否触发兵器技能
            var skill = targetComp.params.activeSkill;
            var skillType = skill.skillType,
                status = skill.status,
                skillId = skill.skillId,
                prob = skill.skillProb;
            /*<---------- 测试用例start  */
            if (targetComp.isSelf && targetComp.params.weaponType == 2) {
                var testId = 61;

                var tempArr = [{
                    skillId: 43,
                    weaponId: ['d001_1', "d005_2", "d007_2", "d008_2", "d009_2", "d011_2", "d012_2"].randomItem
                }, {
                    skillId: 44,
                    weaponId: "d013_3"
                }, {
                    skillId: 45,
                    weaponId: "d009_2"
                }, {
                    skillId: 46,
                    weaponId: "d014_3"
                }, {
                    skillId: 47,
                    weaponId: "d006_2"
                }, {
                    skillId: 48,
                    weaponId: "d006_2"
                }, {
                    skillId: 49,
                    weaponId: "z009_2"
                }, {
                    skillId: 53,
                    weaponId: ["z001_1", "z006_2", "z011_2"].randomItem
                }, {
                    skillId: 54,
                    weaponId: ["z004_2", "z008_2"].randomItem
                }, {
                    skillId: 55,
                    weaponId: "z015_3"
                }, {
                    skillId: 60,
                    weaponId: 'g014_3'
                }, {
                    skillId: 56,
                    weaponId: ["g001_1", "g007_2", "g008_2", "g011_2"].randomItem
                }, {
                    skillId: 57,
                    weaponId: "g010_2"
                }, {
                    skillId: 59,
                    weaponId: ["z007_2", "g009_2"].randomItem
                }, {
                    skillId: 61,
                    weaponId: "g013_3"
                }];
                var tempWeaponInfo = {};
                for (var i = 0; i < tempArr.length; i++) {
                    if (testId == tempArr[i].skillId) {
                        tempWeaponInfo = tempArr[i];
                        break;
                    }
                };

                var _tempWeaponInfo = tempWeaponInfo,
                    _skillId = _tempWeaponInfo.skillId,
                    weaponId = _tempWeaponInfo.weaponId;

                skill.skillId = _skillId;
                targetComp.params.weaponId = weaponId;
                console.error('释放特技:', skill.skillId);
                switch (skill.skillId) {
                    case 43:
                        skill.skillConfig = {
                            weaponNum: 2
                        };
                        break;
                    case 44:
                        skill.skillConfig = {
                            weaponNum: 3
                        };
                        break;
                    case 45:
                        skill.skillConfig = {
                            poison: "6-60"
                        };
                        break;
                    case 46:
                        skill.skillConfig = {
                            poison: "6-210"
                        };
                        break;
                    case 47:
                        skill.skillConfig = {
                            hurt: 3
                        };
                        break;
                    case 48:
                        skill.skillConfig = {
                            poison: 5
                        };
                        break;
                    case 53:
                        skill.skillConfig = {
                            stealHp: 1
                        };
                        break;
                    case 54:
                        skill.skillConfig = {
                            stealMp: 0.4
                        };
                        break;
                    case 55:
                        skill.skillConfig = {
                            recoverDown: "5-0.4"
                        };
                        break;
                    case 56:
                        skill.skillConfig = {
                            hurt: 1.5
                        };
                        break;
                    case 57:
                        skill.skillConfig = {
                            hurt: 2.5
                        };
                        break;
                    case 60:
                        skill.skillConfig = {
                            way: 4
                        };
                        break;
                    case 61:
                        skill.skillConfig = {
                            hurt: 3.5
                        };
                        break;

                }
            }
            /*<---------- 测试用例end----------> */
            var params = JSON.parse(JSON.stringify(targetComp.params)); //深拷贝,便于修改
            params.skillEffect = false;
            params.isSelf = targetComp.isSelf;
            if (skillType == 1 && status == 1) {
                var random = Math.floor(Math.random() * 100 + 1);
                if (random <= 100) {
                    /* 区分哪些是影响自身表现的，哪些是影响对手伤害的 */
                    if (skillId == 58) {
                        targetComp.startT(200); //快速冷却     
                    } else {
                        //正常开始技能冷却
                        targetComp.startT();
                    }
                    this.weaponWithSkills(params, skillId);
                    return;
                } else {
                    console.warn('不好意思,没有触发技能');
                }
            }
            //正常开始技能冷却
            targetComp.startT();
            this.weaponLaunch(params);
        }
    }, {
        key: 'weaponLaunch',
        value: function weaponLaunch(params) {
            var _this4 = this;

            var deltaT = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;

            var name = params.isSelf ? 'self' : 'other';
            var weapon = Laya.Pool.getItemByCreateFun("weapon", this.weapon.create, this.weapon);
            var weaponComp = weapon.getComponent(_Weapon2.default);
            weapon.params = params;
            weaponComp.isSelf = params.isSelf;
            if (params.isSelf) {
                weapon.pos(280, 450);
            } else {
                weapon.pos(1050, 450);
            }

            //暂定
            if (deltaT) {
                Laya.timer.once(deltaT, this, function () {
                    _this4.owner.addChild(weapon);
                    _this4[name + 'Weapons'].push(weaponComp);
                });
            } else {
                this.owner.addChild(weapon);
                this[name + 'Weapons'].push(weaponComp);
            }
        }
        //以下下是正常点击发射

    }, {
        key: 'weaponBySelf',
        value: function weaponBySelf(params, deltaT) {
            var _this5 = this;

            var weapon = Laya.Pool.getItemByCreateFun("weapon", this.weapon.create, this.weapon);
            var weaponComp = weapon.getComponent(_Weapon2.default);
            weapon.params = params;
            weaponComp.isSelf = true;
            /*  this.owner.addChild(weapon); */
            weapon.pos(340, 450);
            //暂定
            if (deltaT) {
                Laya.timer.once(deltaT, this, function () {
                    _this5.owner.addChild(weapon);
                    _this5.selfWeapons.push(weaponComp);
                });
            } else {
                this.owner.addChild(weapon);
                this.selfWeapons.push(weaponComp);
            }
        }
    }, {
        key: 'weaponByOther',
        value: function weaponByOther(target) {
            var weapon = Laya.Pool.getItemByCreateFun("weapon", this.weapon.create, this.weapon);
            var weaponComp = weapon.getComponent(_Weapon2.default);
            weapon.params = target;
            weaponComp.isSelf = false;
            // weapon.isSelf=true;
            this.owner.addChild(weapon);
            weapon.pos(953, 450);

            //暂定
            this.otherWeapons.push(weaponComp);
        }
        //带着技能发射

    }, {
        key: 'weaponWithSkills',
        value: function weaponWithSkills(params, skillId) {
            var skillConfig = params.activeSkill.skillConfig;
            var hurt = skillConfig.hurt;
            var durable = skillConfig.durable;
            params.skillEffect = true; //代表技能是触发的
            switch (skillId) {
                case 43:
                case 44:
                    var weaponNum = skillConfig.weaponNum;

                    console.error("修改后的值:", params.weaponAttack);
                    this.weaponLaunch(params);
                    for (var i = 0; i < weaponNum - 1; i++) {
                        this.weaponLaunch(params);
                    }
                    break;
                //造成几倍伤害 兵器前方加气流
                case 47:
                case 48:
                    // params.weaponAttack = params.weaponAttack * hurt;
                    this.weaponLaunch(params);
                    break;
                //向上中路各发出1件兵器 几率12%
                case 51:
                    params.weaponType = 2;
                    this.weaponLaunch(params);
                    params.weaponType = 3;
                    this.weaponLaunch(params);
                    break;
                // 向上中下路各发出1件兵器 几率8%
                case 52:
                    params.weaponType = 1;
                    this.weaponLaunch(params);
                    params.weaponType = 2;
                    this.weaponLaunch(params);
                    params.weaponType = 3;
                    this.weaponLaunch(params);
                    break;
                //100%伤害转化为生命 几率18%
                case 45:
                case 46:
                case 49:
                case 50:
                case 53:
                case 54:
                case 55:
                case 59:
                    this.weaponLaunch(params);
                    break;
                case 60:
                    params.weaponType = 4;
                    this.weaponLaunch(params);
                    break;
                //造成几倍伤害 兵器上加刀刃特效
                case 56:
                case 57:
                case 61:
                    // params.weaponAttack = params.weaponAttack * hurt;
                    this.weaponLaunch(params);
                    break;
                //兵器耐久提升100%
                case 62:
                    params.weaponDurable = params.weaponDurable * durable;
                    this.weaponLaunch(params);
                    break;

            }
        }
    }, {
        key: 'removeWeapon',
        value: function removeWeapon(target) {
            var targetWeapons = target.isSelf ? this.selfWeapons : this.otherWeapons;
            for (var i = 0, len = targetWeapons.length; i < len; i++) {
                if (targetWeapons[i] == target) {
                    targetWeapons.splice(i, 1);
                    //console.log("删除自己")
                    break;
                }
            }
            console.log('删除后数组' + target.isSelf, targetWeapons);
        }
        //闪避技能

    }, {
        key: 'dodgeSkillShow',
        value: function dodgeSkillShow(isSelf) {
            var name = isSelf ? 'self' : 'other';
            console.error('闪避技能使用');
            this[name + 'Player'].comp.dodgeEffect();
        }
        // 全局碰撞检测

    }, {
        key: 'collisionDetection',
        value: function collisionDetection() {}
        //关卡结束

    }, {
        key: 'passOver',
        value: function passOver() {}
    }, {
        key: 'gameOver',
        value: function gameOver(loserIsSelf) {
            if (!loserIsSelf) {
                this.selfPlayer.comp.skeleton.play('win', true);
            }
            Laya.timer.clearAll(this);
            console.error('游戏结束');
        }
    }, {
        key: 'onDestroy',
        value: function onDestroy() {
            Laya.timer.clearAll(this);
        }
    }]);

    return GameControl;
}(PaoYa.Component);

exports.default = GameControl;

},{"./WeaponManager":6,"./prefab/Dodge":9,"./prefab/HPBar":11,"./prefab/MPBar":12,"./prefab/Player":13,"./prefab/Skill":14,"./prefab/Weapon":15,"./prefab/WeaponBar":16}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MPBar = require("./prefab/MPBar");

var _MPBar2 = _interopRequireDefault(_MPBar);

var _HPBar = require("./prefab/HPBar");

var _HPBar2 = _interopRequireDefault(_HPBar);

var _GameBanner = require("./prefab/GameBanner");

var _GameBanner2 = _interopRequireDefault(_GameBanner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameView = function (_PaoYa$View) {
    _inherits(GameView, _PaoYa$View);

    function GameView() {
        _classCallCheck(this, GameView);

        return _possibleConstructorReturn(this, (GameView.__proto__ || Object.getPrototypeOf(GameView)).call(this));
    }

    _createClass(GameView, [{
        key: "onAwake",
        value: function onAwake() {
            this.selfMPBarScr = this.boxSelfInfo.getChildByName('boxMPBar').getComponent(_MPBar2.default);
            this.selfHPBarScr = this.boxSelfInfo.getChildByName('boxHPBar').getComponent(_HPBar2.default);

            this.otherMPBarScr = this.boxOtherInfo.getChildByName('boxMPBar').getComponent(_MPBar2.default);
            this.otherHPBarScr = this.boxOtherInfo.getChildByName('boxHPBar').getComponent(_HPBar2.default);

            this.gameBannerScr = this.boxGameBanner.getComponent(_GameBanner2.default);
            this.gameBannerScr.changeStyle({ gameStyle: 'battle' });
        }
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "initView",
        value: function initView() {}
        //  GameStyle

        /*  initGameStyle(bannerPrefab,params){
            let banner= 
         } */

    }, {
        key: "setInfo",
        value: function setInfo(data, isSelf) {
            var boxInfo = isSelf ? this.boxSelfInfo : this.boxOtherInfo;
            var imgIcon = boxInfo.getChildByName('imgIcon');
            var lblName = boxInfo.getChildByName("lblName");
            imgIcon.skin = data.icon;
            lblName.text = data.name;
            /*    console.log(this.boxSelfInfo.getChildByName("boxMPBar"));
               console.log(this.boxOtherInfo.getChildByName('boxHPBar')); */
        }
    }, {
        key: "setHPbar",
        value: function setHPbar(value, isSelf) {
            var HPBarScr = isSelf ? this.selfHPBarScr : this.otherHPBarScr;
        }
    }, {
        key: "setMPBar",
        value: function setMPBar(value, isSelf) {
            var MPBarScr = isSelf ? this.selfMPBarScr : this.otherMPBarScr;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {}
    }]);

    return GameView;
}(PaoYa.View);

exports.default = GameView;

},{"./prefab/GameBanner":10,"./prefab/HPBar":11,"./prefab/MPBar":12}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WeaponManager = function (_Laya$Script) {
  _inherits(WeaponManager, _Laya$Script);

  function WeaponManager(robotWeaponList) {
    _classCallCheck(this, WeaponManager);

    var _this = _possibleConstructorReturn(this, (WeaponManager.__proto__ || Object.getPrototypeOf(WeaponManager)).call(this));

    _this.weaponList = [];
    for (var i = 0, len = robotWeaponList.length; i < len; i++) {
      var weapon = new PrivateWeapon(robotWeaponList[i]);
      _this.weaponList.push(weapon);
    }
    return _this;
  }

  _createClass(WeaponManager, [{
    key: 'seletedWeapon',
    value: function seletedWeapon() {
      var weapons = [];
      for (var i = 0, len = this.weaponList.length; i < len; i++) {
        if (!this.weaponList[i].freezeing) {
          console.warn("可用兵器id:", this.weaponList[i].params.weaponName);
          weapons.push(this.weaponList[i]);
        }
      }
      var random = Math.floor(Math.random() * weapons.length);
      return weapons[random];
    }
  }]);

  return WeaponManager;
}(Laya.Script);

exports.default = WeaponManager;

var PrivateWeapon = function () {
  function PrivateWeapon(weaponParams) {
    _classCallCheck(this, PrivateWeapon);

    this.params = deepMerge(weaponParams);
    this.freezeing = false;
    this.isSelf = false;
    this.weaponConsume = this.params.weaponConsume;
  }

  _createClass(PrivateWeapon, [{
    key: 'selectedHandler',
    value: function selectedHandler() {
      if (this.freezeing) {
        console.error('机器人兵器冷却中，不可使用');
        return false;
      }
      this.freezeing = true;

      /*  return this.config; */
    }
  }, {
    key: 'startT',
    value: function startT() {
      console.error('机器人兵器进行冷却');
      Laya.timer.once(this.params.weaponCd * 1000, this, this.changeStatus);
    }
  }, {
    key: 'changeStatus',
    value: function changeStatus() {
      this.freezeing = false;
    }
  }]);

  return PrivateWeapon;
}();

function deepMerge() {
  var result = Object.create(null);

  for (var _len = arguments.length, objs = Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }

  objs.forEach(function (obj) {
    if (obj) {
      Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        if (isPlainObject(val)) {
          if (isPlainObject(result[key])) {
            result[key] = deepMerge(result[key], val);
          } else {
            result[key] = deepMerge(val);
          }
        } else {
          result[key] = val;
        }
      });
    }
  });
  return result;
}
function isPlainObject(val) {
  return Object.prototype.toString.call(val) === '[object Object]';
}

},{}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var HeroConfig = {

  roleName: '独孤九剑',
  roleIcon: '',
  roleHp: 100, //HP:hit point 生命值,roleUp为0,game over
  roleMp: 100, //MP:magic point 内力，体力  内力恢复公式：每30帧内力恢复量=roleUp/390*30。
  /*  */
  roleStrength: 2, //arm strength ,臂力值决定兵器基础伤害值。兵器基础伤害=兵器攻击力*（roleStrength-对方根骨）/roleStrength
  roleBone: 2, //根骨  .值越大收到兵器攻击受到的伤害越小
  roleCritProb: 20, //暴击几率 ,
  roleCritHarm: 100, //暴伤百分比，兵器造成伤害=兵器基础伤害*roleCritHarm
  roleSkills: [{
    skillConfig: {},
    skillDesc: ""
  }, {}],
  spineMap: {
    freeze: {
      path: "spine/freeze/freeze.sk",
      name: ['continue', 'freeze'],
      ready_go: 1,
      templet: null
    },
    npc_7: {
      path: "spine/npc/npc_7.sk",
      name: ['bomb'],
      bomb: 0,
      templet: null
    }
  },
  /* 提供给外部获取动画的接口，输入动画名字即可 */
  getSkeleton: function getSkeleton(spineName) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var skeleton;
    if (this.spineMap[spineName].templet) {
      skeleton = this.spineMap[spineName].templet.buildArmature(index);
    } else {
      skeleton = new Laya.Skeleton();
      skeleton.load(this.spineMap[spineName].path);
    }
    return skeleton;
  },
  loadAllSpine: function loadAllSpine() {
    this.loadIndex = 0;
    var spines = Object.keys(this.spineMap);
    this.preload(spines);
  },
  preload: function preload(spines) {
    var _this = this;
    var spine = this.spineMap[spines[this.loadIndex]];
    this.loadSpine(spine.path, function (templet) {
      spine.templet = templet;
      if (_this.loadIndex == spines.length - 1) {
        return;
      } else {
        _this.loadIndex++;
        _this.preload(spines);
      }
    }, function () {
      if (_this.loadIndex == spines.length - 1) {
        return;
      } else {
        _this.loadIndex++;
        _this.preload(spines);
      }
    });
  },
  loadSpine: function loadSpine(url, completion, error) {
    var templet = new Laya.Templet();
    templet.on(Laya.Event.COMPLETE, this, function () {
      completion && completion(templet);
    });
    templet.on(Laya.Event.ERROR, this, function () {
      console.error("E: Load spine, skin:" + url);
      error && error();
    });
    templet.loadAni(url);
  }
  //英雄携带的兵器
  //每个英雄对应的技能，和技能对应的动画效果
};exports.default = HeroConfig;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PassResultDialog = function (_PaoYa$Dialog) {
    _inherits(PassResultDialog, _PaoYa$Dialog);

    function PassResultDialog() {
        _classCallCheck(this, PassResultDialog);

        return _possibleConstructorReturn(this, (PassResultDialog.__proto__ || Object.getPrototypeOf(PassResultDialog)).call(this));
    }

    _createClass(PassResultDialog, [{
        key: "onAwake",
        value: function onAwake() {
            console.log(this.params);
        }
    }]);

    return PassResultDialog;
}(PaoYa.Dialog);

exports.default = PassResultDialog;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GameControl = require("../GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dodge = function (_PaoYa$Component) {
    _inherits(Dodge, _PaoYa$Component);

    /* @prop {name:spShadow,tips:"阴影遮罩",type:Node} */
    function Dodge() {
        _classCallCheck(this, Dodge);

        return _possibleConstructorReturn(this, (Dodge.__proto__ || Object.getPrototypeOf(Dodge)).call(this));
    }

    _createClass(Dodge, [{
        key: "onAwake",
        value: function onAwake() {
            var owner = this.owner;
            this.ownW = owner.width;
            this.ownH = owner.height;
            this.spShadow.visible = false;
            this.maskArea = new Laya.Sprite();
            this.maskArea.texture = "remote/game/dodge.png";
            owner.addChild(this.maskArea);

            this.spMask = new Laya.Sprite();
            this.maskArea.mask = this.spMask;

            this.cdTime = 20000;
            this.freezeing = false;
            this.maxAngle = 270;
            this.startAngle = -90;
            this.endAngle = -90;
            owner.on(Laya.Event.CLICK, this, this.clickHandler);
        }
    }, {
        key: "clickHandler",
        value: function clickHandler() {
            if (this.freezeing) {
                console.warn("冷却中不接受点击");
                return;
            }
            _GameControl2.default.instance.dodgeSkillShow(true);
            this.startT();
        }
    }, {
        key: "startT",
        value: function startT(time) {

            this.spShadow.visible = true;
            this.maskArea.visible = true;
            this.freezeing = true;

            this.beiginTime = new Date().getTime();

            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.ownW / 2, this.ownH / 2, this.ownW, this.startAngle, this.endAngle, "#000000");
            //Laya.timer.loop(this.frameCd, this, this.startCd);
            var cdT = time == undefined ? this.cdTime : time;
            Laya.timer.frameLoop(1, this, this.startCd, [cdT]);
        }
    }, {
        key: "startCd",
        value: function startCd(time) {
            //  console.log("时间间隔：",this.frameCd);
            if (this.endAngle >= this.maxAngle) {
                this.endCD();
                return;
            }
            this.endAngle += Laya.timer.delta * 360 / time;
            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.ownW / 2, this.ownH / 2, this.ownW, this.startAngle, this.endAngle, "#000000");
        }
    }, {
        key: "endCD",
        value: function endCD() {
            Laya.timer.clearAll(this);
            this.maskArea.visible = false;
            this.spShadow.visible = false;
            this.freezeing = false;
            this.endAngle = -90;
        }
    }]);

    return Dodge;
}(PaoYa.Component);

exports.default = Dodge;

},{"../GameControl":4}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GameControl = require("../GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameBanner = function (_PaoYa$Component) {
    _inherits(GameBanner, _PaoYa$Component);

    /** @prop {name:spGameStyle,tips:'比赛类型精灵图',type:Node}*/
    /** @prop {name:lblTime,tips:'时间label',type:Node}*/
    function GameBanner() {
        _classCallCheck(this, GameBanner);

        return _possibleConstructorReturn(this, (GameBanner.__proto__ || Object.getPrototypeOf(GameBanner)).call(this));
    }

    _createClass(GameBanner, [{
        key: "onAwake",
        value: function onAwake() {
            this.startCount();
        }
    }, {
        key: "changeStyle",
        value: function changeStyle(params) {
            if (params.gameStyle == "macth") {
                this.spGameStyle.texture = "remote/game/23.png";
            } else {
                this.spGameStyle.texture = "remote/game/23.png";
            }
        }
    }, {
        key: "startCount",
        value: function startCount() {
            var _this2 = this;

            /*    console.log(this.spGameStyle)
               console.log(this.lblTime) */
            var timerService = new PaoYa.TimerService(1000, 1, true);
            timerService.on(PaoYa.TimerService.PROGRESS, this, function (time) {

                _this2.lblTime.text = time.formatTime('M:S') + "";
            });
            timerService.on(PaoYa.TimerService.STOP, this, function () {});
            // GameControl.instance.timerService=timerService;
            timerService.start();
        }
    }]);

    return GameBanner;
}(PaoYa.Component);

exports.default = GameBanner;

},{"../GameControl":4}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HPBar = function (_PaoYa$Component) {
  _inherits(HPBar, _PaoYa$Component);

  /** @prop {name:imgHp,tips:"血条图片",type:Node} */
  /** @prop {name:imgMask,tips:"血条mask",type:Node} */
  /** @prop {name:lblHpPct,tips:"hp百分比",type:Node} */
  function HPBar() {
    _classCallCheck(this, HPBar);

    return _possibleConstructorReturn(this, (HPBar.__proto__ || Object.getPrototypeOf(HPBar)).call(this));
  }

  _createClass(HPBar, [{
    key: 'onAwake',
    value: function onAwake() {}
  }, {
    key: 'onEnable',
    value: function onEnable() {}
  }, {
    key: 'initBar',
    value: function initBar(HPValue) {
      this.originW = this.owner.width;
      console.log('初始的血量值:', HPValue);
      this.originHP = this.curHP = HPValue;
      this.lblHpPct.text = this.curHP + '/' + this.originHP;
    }
  }, {
    key: 'changeHP',
    value: function changeHP(value) {
      this.curHP += value;
      if (this.curHP <= 0) {
        this.curHP = 0;
        this.imgMask.width = 0;
        return;
      } else if (this.curHP > this.originHP) {
        this.curHP = this.originHP;
      }
      this.lblHpPct.text = this.curHP + '/' + this.originHP;
      var w = Math.floor(this.curHP / this.originHP * this.originW);
      this.imgMask.width = w;
    }
  }, {
    key: 'onDisable',
    value: function onDisable() {}
  }, {
    key: 'onDestroy',
    value: function onDestroy() {}
  }]);

  return HPBar;
}(PaoYa.Component);

exports.default = HPBar;

},{}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MPBar = function (_PaoYa$Component) {
    _inherits(MPBar, _PaoYa$Component);

    /** @prop {name:imgMP,tips:"内力条图片",type:Node} */
    /** @prop {name:imgMask,tips:"内力条mask",type:Node} */
    /** @prop {name:lblMpPct,tips:"mp百分比",type:Node} */
    function MPBar() {
        _classCallCheck(this, MPBar);

        return _possibleConstructorReturn(this, (MPBar.__proto__ || Object.getPrototypeOf(MPBar)).call(this));
    }

    _createClass(MPBar, [{
        key: 'onAwake',
        value: function onAwake() {

            this.originW = this.owner.width;
            this.imgMP.mask = this.imgMask;
        }
    }, {
        key: 'onEnable',
        value: function onEnable() {}
    }, {
        key: 'initBar',
        value: function initBar(MPValue) {
            console.log('初始的体力值:', MPValue);
            this.originMP = this.curMP = MPValue;
            this.perAddMP = Math.floor(this.originMP / 390 * 30);
            this.originPerAddMP = this.perAddMP;
            this.lblMpPct.text = this.curMP + '/' + this.originMP;
            this.startBar();
        }
    }, {
        key: 'startBar',
        value: function startBar() {
            Laya.timer.loop(500, this, this.autoIncreaseBar);
        }
    }, {
        key: 'autoIncreaseBar',
        value: function autoIncreaseBar() {
            if (this.curMP >= this.originMP) {
                // console.warn("内力已经满了")
                return;
            }
            var addedValue = Number((this.curMP + this.perAddMP).toFixed(1));
            this.curMP = addedValue > this.originMP ? this.originMP : addedValue;
            this.lblMpPct.text = this.curMP + '/' + this.originMP;
            this.imgMask.width = Math.floor(this.curMP / this.originMP * this.originW);
        }
    }, {
        key: 'changeMP',
        value: function changeMP(value) {
            this.curMP += value;
            if (this.curMP < 0) {
                this.curMP = 0;
            } else if (this.curMP > this.originMP) {
                this.curMP = this.originMP;
            }
            this.imgMask.width = Math.floor(this.curMP / this.originMP * this.originW);
            this.lblMpPct.text = this.curMP + '/' + this.originMP;
        }
    }, {
        key: 'changePerMP',
        value: function changePerMP(value) {

            this.perAddMP = value;
        }
    }, {
        key: 'updateBar',
        value: function updateBar() {}
    }, {
        key: 'onDisable',
        value: function onDisable() {
            Laya.timer.clear(this, this.increaseBar);
        }
    }, {
        key: 'onDestroy',
        value: function onDestroy() {}
    }]);

    return MPBar;
}(PaoYa.Component);

exports.default = MPBar;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _HeroConfig = require("../config/HeroConfig");

var _HeroConfig2 = _interopRequireDefault(_HeroConfig);

var _GameControl = require("../GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Player = function (_PaoYa$Component) {
  _inherits(Player, _PaoYa$Component);

  /** @prop {name:boxAniBot,tips:"受击动效box",type:Node} */
  /** @prop {name:aniBot,tips:"受击动效节点",type:Node} */
  /** @prop {name:boxAniMid,tips:"中间受击动效box",type:Node} */
  /** @prop {name:aniMid,tips:"受击动效节点",type:Node} */
  /** @prop {name:boxAniTop,tips:"顶部动效box",type:Node} */
  /** @prop {name:aniTop,tips:"受击动效节点",type:Node} */
  /** @prop {name:boxAniPalsy,tips:"麻痹动效box",type:Node} */
  /** @prop {name:aniPalsy,tips:"麻痹动效节点",type:Node} */
  /** @prop {name:boxAniDizzy,tips:"眩晕动效box",type:Node} */
  /** @prop {name:aniDizzy,tips:"眩晕动效节点",type:Node} */
  /** @prop {name:boxAniHp,tips:"回血动效box",type:Node} */
  /** @prop {name:aniHp,tips:"回血动效节点",type:Node} */
  /** @prop {name:boxAniMp,tips:"回蓝动效box",type:Node} */
  /** @prop {name:aniMp,tips:"回蓝动效节点",type:Node} */

  /** @prop {name:boxAniSkill,tips:"技能触发动效box",type:Node} */
  /** @prop {name:aniSkill,tips:"技能动效节点",type:Node} */
  /** @prop {name:boxAniUp,tips:"英雄升级动效box",type:Node} */
  /** @prop {name:aniUp,tips:"英雄升级动效节点",type:Node} */
  /** @prop {name:boxAniPoison,tips:"中毒动效box",type:Node} */
  /** @prop {name:aniPoison,tips:"中毒动效节点",type:Node} */
  /** @prop {name:boxAniDodge,tips:"闪避动效box",type:Node} */
  /** @prop {name:aniDodge,tips:"闪避动效节点",type:Node} */

  function Player() {
    _classCallCheck(this, Player);

    return _possibleConstructorReturn(this, (Player.__proto__ || Object.getPrototypeOf(Player)).call(this));
  }

  _createClass(Player, [{
    key: "onAwake",
    value: function onAwake() {
      var _this2 = this;

      //this.params=this.owner.params;
      var owner = this.owner;
      this.typeAniName = ["", "Bot", "Mid", "Top", "Top"]; //对应轨迹的动画名称

      var width = owner.width,
          height = owner.height;

      var skeleton = new Laya.Skeleton();
      var posX = Math.floor(width / 2),
          posY = height;
      skeleton.pos(posX, posY - 10);
      this.skeleton = skeleton;
      this.sectionAni = 0; //分段动画
      //不管什么状态播放完，都继续播放待机状态
      this.skeleton.on(Laya.Event.STOPPED, this, function () {
        Laya.MouseManager.enabled = true;
        if (_this2.HPComp.curHP <= 0) {
          _this2.skeleton.playbackRate(1);
          return;
        }
        if (_this2.sectionAni == 1) {
          _this2.sectionAni += 1;
          _this2.skeleton.play('dodge2', false);
          return;
        }
        if (_this2.sectionAni == 2) {
          _this2.sectionAni += 1;
          _this2.skeleton.play('dodge3', false);
          return;
        }
        if (_this2.sectionAni == 3) {
          _this2.removeDodge();
          return;
        }
        _this2.skeleton.playbackRate(1);
        _this2.skeleton.play('stand', true);
      });
      owner.addChild(skeleton);

      var freeze = _HeroConfig2.default.getSkeleton('freeze');
      freeze.pos(posX, posY);
      this.owner.addChild(freeze);
      this.freeze = freeze;

      this.canAction = true;
      this.initDress();
    }
  }, {
    key: "onEnable",
    value: function onEnable() {}
  }, {
    key: "initDress",
    value: function initDress() {
      var _this3 = this;

      var url = "spine/hero/hero_1.sk";
      this.skeleton.load(url, Laya.Handler.create(this, function () {
        // this.skeleton.play('dizzy', true);
        _this3.skeleton.play('stand', true);
        /*   this.skeleton.playbackRate(1)
          this.skeleton.play('win',true); */
      }));
    }

    //攻击

  }, {
    key: "attackEffect",
    value: function attackEffect() {
      this.skeleton.playbackRate(1);
      this.skeleton.play("attack", false);
    }
    //受击打,所有武器碰到都有这效果

  }, {
    key: "injuredEffect",
    value: function injuredEffect(type, value) {
      this.canAction = false;
      if (this.isSelf) {
        Laya.MouseManager.enabled = false;
      }
      this.HPComp.changeHP(value);
      if (this.HPComp.curHP <= 0) {
        console.error('死亡结束');
        _GameControl2.default.instance.gameOver(this.isSelf);
        this.skeleton.play("death", false);
        return;
      }
      var aniName = this.typeAniName[type];
      this.skeleton.play("injured", false);
      this['boxAni' + aniName].visible = true;
      this['ani' + aniName].play(0, false);
    }
  }, {
    key: "hpRecoverEffect",
    value: function hpRecoverEffect(value) {
      this.boxAniHp.visible = true;
      this.aniHp.play(0, false);
      this.HPComp.changeHP(value);
    }
    //恢复内力

  }, {
    key: "mpRecoverEffect",
    value: function mpRecoverEffect(value) {
      this.boxAniMp.visible = true;
      this.aniMp.play(0, false);
      this.MPComp.changeMP(value);
    }
    //中毒

  }, {
    key: "poisonEffect",
    value: function poisonEffect(poisonTime, hpValue) {
      this.canAction = false;
      if (this.isSelf) {
        Laya.MouseManager.enabled = false;
      }
      this.boxAniPoison.visible = true;
      this.aniPoison.play(0, true);
      var startTime = new Date().getTime();
      var endTime = startTime + poisonTime;
      this.HPComp.changeHP(hpValue);
      Laya.timer.loop(1000, this, this.minusHp, [endTime, hpValue]);
    }
  }, {
    key: "minusHp",
    value: function minusHp(endTime, hpValue) {
      if (new Date().getTime() > endTime) {
        this.removePoison();
        Laya.timer.clear(this, this.minusHp);
        return;
      }
      this.HPComp.changeHP(hpValue);
    }
  }, {
    key: "removePoison",
    value: function removePoison() {
      this.canAction = true;
      if (this.isSelf) {
        Laya.MouseManager.enabled = true;
      }
      this.boxAniPoison.visible = false;
      this.aniPoison.stop();
    }
    //x眩晕

  }, {
    key: "dizzyEffect",
    value: function dizzyEffect(dizzyTime) {
      this.canAction = false;
      if (this.isSelf) {
        Laya.MouseManager.enabled = false;
      }
      this.boxAniPalsy.visible = true;
      //  this.HPComp.changeHP(value)
      this.aniPalsy.play(0, true);

      this.skeleton.play('dizzy', true);
      Laya.timer.once(dizzyTime, this, this.removeDizzy);
    }
  }, {
    key: "removeDizzy",
    value: function removeDizzy() {
      this.canAction = true;
      if (this.isSelf) {
        Laya.MouseManager.enabled = true;
      }
      this.skeleton.play('stand', true);
      this.boxAniPalsy.visible = false;
      this.aniPalsy.stop();
    }
    //人物触发兵器技能特效

  }, {
    key: "skillEffect",
    value: function skillEffect() {
      this.boxAniSkill.visible = true;
      this.aniSkill.play(0, false);
    }
    //冰冻

  }, {
    key: "freezedEffect",
    value: function freezedEffect() {
      var freezeTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;

      this.canAction = false;
      if (this.isSelf) {
        Laya.MouseManager.enabled = false;
      }
      this.freeze.visible = true;
      this.skeleton.play('freeze', true);
      this.freeze.play('freeze', false);
      Laya.timer.once(freezeTime, this, this.removeFreeze);
    }
  }, {
    key: "removeFreeze",
    value: function removeFreeze() {
      this.canAction = true;
      if (this.isSelf) {
        Laya.MouseManager.enabled = true;
      }
      this.freeze.visible = false;
      this.skeleton.play('stand', true);
    }
    //闪避技能

  }, {
    key: "dodgeEffect",
    value: function dodgeEffect() {
      this.sectionAni = true;
      this.dodge = true; //闪避无敌状态
      this.owner.zOrder = 100;
      this.skeleton.play('dodge1', false);
      this.boxAniDodge.visible = true;
      this.aniDodge.play(0, true);
    }
  }, {
    key: "removeDodge",
    value: function removeDodge() {
      this.owner.zOrder = 20;
      this.sectionAni = 0;
      this.dodge = false;
      this.boxAniDodge.visible = false;
      this.aniDodge.stop();
    }
  }, {
    key: "changePerMp",
    value: function changePerMp(time, valuePer) {
      this.MPComp.changePerMP(this.MPComp.perAddMP * valuePer);
      Laya.timer.once(time, this, this.recoverPerMp);
    }
  }, {
    key: "recoverPerMp",
    value: function recoverPerMp() {
      this.MPComp.changePerMP(this.MPComp.originPerAddMP);
    }
  }, {
    key: "onDisable",
    value: function onDisable() {}
  }, {
    key: "onDestroy",
    value: function onDestroy() {}
  }]);

  return Player;
}(PaoYa.Component);

exports.default = Player;

},{"../GameControl":4,"../config/HeroConfig":7}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Skill = function (_PaoYa$Component) {
    _inherits(Skill, _PaoYa$Component);

    /* @prop {name:spShadow,tips:"阴影遮罩",type:Node} */
    function Skill() {
        _classCallCheck(this, Skill);

        return _possibleConstructorReturn(this, (Skill.__proto__ || Object.getPrototypeOf(Skill)).call(this));
    }

    _createClass(Skill, [{
        key: "onAwake",
        value: function onAwake() {
            var owner = this.owner;
            this.ownW = owner.width;
            this.ownH = owner.height;
            this.centerX = Math.floor(this.ownW / 2);
            this.centerY = Math.floor(this.ownH / 2);
            this.spShadow.visible = false;
            this.maskArea = new Laya.Sprite();
            this.maskArea.texture = "remote/game/skill.png";
            owner.addChild(this.maskArea);

            this.spMask = new Laya.Sprite();
            this.maskArea.mask = this.spMask;

            this.freezeing = false;
            this.maxAngle = 270;
            this.startAngle = -90;
            this.endAngle = -90;
            owner.on(Laya.Event.CLICK, this, this.clickHandler);
        }
    }, {
        key: "clickHandler",
        value: function clickHandler() {
            if (this.freezeing) {
                console.warn("冷却中不接受点击");
                return;
            }

            this.startT();
        }
    }, {
        key: "initCdTime",
        value: function initCdTime(cdTime) {
            console.warn('初始化cd时间:', cdTime);
            //cd 时间
            this.cdTime = cdTime;
        }
    }, {
        key: "setCdTime",
        value: function setCdTime(cdTime) {
            console.warn('修改cd时间:', cdTime);
            //cd 时间
            this.cdTime = cdTime;
        }
    }, {
        key: "startT",
        value: function startT(time) {

            this.spShadow.visible = true;
            this.maskArea.visible = true;
            this.freezeing = true;

            this.beiginTime = new Date().getTime();

            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.centerX, this.centerY, this.ownW, this.startAngle, this.endAngle, "#000000");
            var cdT = time == undefined ? this.cdTime : time;
            Laya.timer.frameLoop(1, this, this.startCd, [cdT]);
        }
    }, {
        key: "startCd",
        value: function startCd(time) {
            //  console.log("时间间隔：",this.frameCd);
            if (this.endAngle >= this.maxAngle) {
                this.endCD();
                return;
            }
            this.endAngle += Laya.timer.delta * 360 / time;
            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.centerX, this.centerY, this.ownW, this.startAngle, this.endAngle, "#000000");
        }
    }, {
        key: "endCD",
        value: function endCD() {
            Laya.timer.clearAll(this);
            this.maskArea.visible = false;
            this.spShadow.visible = false;
            this.freezeing = false;
            this.endAngle = -90;
        }
    }]);

    return Skill;
}(PaoYa.Component);

exports.default = Skill;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GameControl = require("../GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WeaponAniType;
(function (WeaponAniType) {
  WeaponAniType[WeaponAniType["aniRepeat1"] = 43] = "aniRepeat1";
  WeaponAniType[WeaponAniType["aniRepeat2"] = 44] = "aniRepeat2";
  WeaponAniType[WeaponAniType["aniPoison1"] = 45] = "aniPoison1";
  WeaponAniType[WeaponAniType["aniPoison2"] = 46] = "aniPoison2";
  WeaponAniType[WeaponAniType["aniCrit1"] = 47] = "aniCrit1";
  WeaponAniType[WeaponAniType["aniCrit2"] = 48] = "aniCrit2";
  WeaponAniType[WeaponAniType["aniBlood"] = 53] = "aniBlood";
  WeaponAniType[WeaponAniType["aniBlue"] = 54] = "aniBlue";
  WeaponAniType[WeaponAniType["aniReduce"] = 55] = "aniReduce";
  WeaponAniType[WeaponAniType["aniThump1"] = 56] = "aniThump1";
  WeaponAniType[WeaponAniType["aniThump2"] = 57] = "aniThump2";
  WeaponAniType[WeaponAniType["aniFreeze"] = 59] = "aniFreeze";
  WeaponAniType[WeaponAniType["aniThump3"] = 61] = "aniThump3";
})(WeaponAniType || (WeaponAniType = {}));

var Weapon = function (_PaoYa$Component) {
  _inherits(Weapon, _PaoYa$Component);

  /** @prop {name:imgWeapon,tips:"四个点",type:Node}*/
  /** @prop {name:boxAniWeapon,tips:"武器碰撞动效Box",type:Node}*/
  /** @prop {name:boxAniCollision,tips:"武器碰撞动效",type:Node}*/
  /** @prop {name:boxHpWeapon,tips:"武器的血条",type:Node}*/
  /** @prop {name:imgHpMask,tips:"武器血条mask",type:Node}*/
  /** @prop {name:imgHp,tips:"武器血条图片",type:Node}*/
  /** @prop {name:aniCrit1,tips:"致命特效",type:Node}*/
  /** @prop {name:aniCrit2,tips:"诛心特效",type:Node}*/
  /** @prop {name:aniPoison1,tips:"浸毒特效",type:Node}*/
  /** @prop {name:aniPoison2,tips:"奇毒特效",type:Node}*/
  /** @prop {name:aniRepeat1,tips:"双刃特效",type:Node}*/
  /** @prop {name:aniRepeat2,tips:"影刃特效",type:Node}*/
  /** @prop {name:aniBlood,tips:"嗜血特效",type:Node}*/
  /** @prop {name:aniBlue,tips:"嗜魔特效",type:Node}*/
  /** @prop {name:aniReduce,tips:"气绝特效",type:Node}*/

  /** @prop {name:aniThump1,tips:"重击特效",type:Node}*/
  /** @prop {name:aniThump2,tips:"碎石特效",type:Node}*/
  /** @prop {name:aniThump3,tips:"斩皇特效",type:Node}*/
  /** @prop {name:aniFreeze,tips:"冰心特效",type:Node}*/

  function Weapon() {
    _classCallCheck(this, Weapon);

    var _this = _possibleConstructorReturn(this, (Weapon.__proto__ || Object.getPrototypeOf(Weapon)).call(this));

    _this.pathsCurvature = [0, 0, 0.0008, 0.0015, 0.0025];
    _this.speedsArr = [0, 680 / 100, 680 / 80, 680 / 100, 680 / 80];
    return _this;
  }

  _createClass(Weapon, [{
    key: "onAwake",
    value: function onAwake() {
      this.tween = new Laya.Tween();

      //添加碰撞体
      var collideSp = new Laya.Sprite();
      this.collideSp = collideSp;
      this.imgWeapon.addChild(collideSp);

      /* 抛物线公式 */
      this.startPos = {
        x: 180,
        y: 450
      };
      this.endPos = {
        x: 1150,
        y: 450
        // X轴Y轴的偏移总量
      };this.driftX = this.endPos.x - this.startPos.x;
      this.driftY = this.endPos.y - this.startPos.y;
    }

    //可能执行多次

  }, {
    key: "onEnable",
    value: function onEnable() {
      this.params = this.owner.params;

      if (this.params.weaponType != 1) {
        this.rotateAngle = 360;
      }
      this.firstAngle = undefined;
      //初始化
      this.imgWeapon.alpha = 1;
      this.imgWeapon.scaleX = 1;
      this.imgWeapon.scaleY = 1;

      this.effectAni = false; //兵器是否在做碰撞动效
      this.boxAniWeapon.visible = false;

      //武器图片 
      this.imgWeapon.skin = "remote/weapons/" + this.params.weaponId + ".png";
      this.weaponAttack = this.params.weaponAttack; //武器攻击力
      this.weaponDurable = this.params.weaponDurable;
      this.owner.zOrder = 100 - this.weaponDurable;
      var imgW = this.imgWeapon.width,
          imgH = this.imgWeapon.height;

      this.imgWeapon.pivot(imgW / 2, imgH / 2); //图片的位置
      var x = this.imgWeapon.x,
          y = this.imgWeapon.y,
          skillX = -Math.floor(imgW / 2);
      this.boxAniWeapon.pos(x, y); //碰撞动效的位置
      this.aniPoison1.pos(x, y);
      this.aniPoison2.pos(skillX, y);
      //  this.boxAniCrit1.pos(x,y);
      this.aniCrit1.pos(x, y);
      this.aniCrit2.pos(skillX + 5, y);
      this.aniRepeat1.pos(skillX + 5, y);
      this.aniRepeat2.pos(skillX + 5, y);

      this.aniBlood.pos(x, y);
      this.aniBlue.pos(x, y);
      this.aniReduce.pos(x, y);
      /* this.aniPoison1.play(0,true); */
      this.collideSp.size(Math.floor(imgW * 0.2), imgH);
      var collideW = this.collideSp.width,
          collideH = this.collideSp.height;
      this.collideW = collideW;
      this.collideH = collideH;

      this.collideSp.pivot(collideW / 2, collideH / 2);
      this.collideSp.pos(imgW / 2, imgH / 2);
      //碰撞区域画图显示
      /* this.collideSp.graphics.clear();
      this.collideSp.graphics.drawRect(0, 0, collideW, collideH, '#ff0000'); */

      this.newX = 0;
      this.newY = 0;

      this.weaponPoint = [{
        x: Math.floor(this.originX - collideW / 2),
        y: Math.floor(this.originY - collideH / 2)
      }, {
        x: Math.floor(this.originX + collideW / 2),
        y: Math.floor(this.originY - collideH / 2)
      }, {
        x: Math.floor(this.originX + collideW / 2),
        y: Math.floor(this.originY + collideH / 2)
      }, {
        x: Math.floor(this.originX - collideW / 2),
        y: Math.floor(this.originY + collideH / 2)
      }];
      var speed = this.speedsArr[this.params.weaponType]; //代表 像素/帧
      //根据weaponType不同，运动轨迹不同,造成curvature
      this.curvature = this.pathsCurvature[this.params.weaponType];
      /*
      * 因为经过(0, 0), 因此c = 0
      * 于是：
      * y = a * x*x + b*x;
      * y1 = a * x1*x1 + b*x1;
      * y2 = a * x2*x2 + b*x2;
      * 利用第二个坐标：
      * b = (y2+ a*x2*x2) / x2
      */
      this.b = (this.driftY - this.curvature * this.driftX * this.driftX) / this.driftX;
      this.initWeaponInfo();
      //初始化血条状态
      this.initBar();
      this.initSkillEffect(); //兵器技能特效
      Laya.timer.frameLoop(1, this, this.startParabola, [speed]);
    }
  }, {
    key: "initBar",
    value: function initBar() {
      this.originHpW = this.imgHp.width;
      this.originHP = this.curHP = this.weaponDurable;
      this.boxHpWeapon.visible = false;
      this.imgHpMask.width = this.originHpW;
    }
  }, {
    key: "initSkillEffect",
    value: function initSkillEffect() {
      if (this.params.skillEffect) {
        var skillId = this.params.activeSkill.skillId;
        if (WeaponAniType[skillId]) {
          this[WeaponAniType[skillId]].visible = true;
          this[WeaponAniType[skillId]].play(0, true);
        }
      }
    }
  }, {
    key: "stopSkillEffect",
    value: function stopSkillEffect() {
      if (this.params.skillEffect) {
        var skillId = this.params.activeSkill.skillId;
        if (WeaponAniType[skillId]) {
          this[WeaponAniType[skillId]].visible = false;
          this[WeaponAniType[skillId]].stop();
        }
      }
    }
  }, {
    key: "initWeaponInfo",
    value: function initWeaponInfo() {
      //暂时这么写  
      if (this.isSelf) {
        this.selfPlayerComp = _GameControl2.default.instance.selfPlayer.comp;
        this.otherPlayerComp = _GameControl2.default.instance.otherPlayer.comp;
        this.owner.scaleX = 1;
      } else {
        this.selfPlayerComp = _GameControl2.default.instance.otherPlayer.comp;
        this.otherPlayerComp = _GameControl2.default.instance.selfPlayer.comp;
        this.owner.scaleX = -1;
      }
      //这个是武器发射的坐标
      this.originX = this.owner.x;
      this.originY = this.owner.y;
      this.diffX = Math.abs(this.originX - this.startPos.x);
      this.beginTime = new Date().valueOf();
    }
  }, {
    key: "changeHP",
    value: function changeHP(value) {
      this.boxHpWeapon.visible = true;

      this.curHP += value;
      if (this.curHP <= 0) {
        this.curHP = 0;
        this.imgMask.width = 0;
        return;
      } else if (this.curHP > this.originHP) {
        this.curHP = this.originHP;
      }
      var w = Math.floor(this.curHP / this.originHP * this.originHpW);
      this.imgHpMask.width = w;
    }

    //开始抛物线运动

  }, {
    key: "startParabola",
    value: function startParabola(speed) {
      var now = new Date().valueOf();
      var x = void 0,
          y = void 0,
          curAngle = void 0;

      x = Math.floor((now - this.beginTime) * 0.06 * speed) + this.diffX;
      y = Math.floor(this.curvature * x * x + this.b * x);
      curAngle = Math.floor(x / this.driftX * 720);
      this.doMove(x, y, curAngle);
    }
  }, {
    key: "stopParabola",
    value: function stopParabola() {
      console.log("清除定时器");
      Laya.timer.clear(this, this.startParabola);
    }
    //运动

  }, {
    key: "doMove",
    value: function doMove(x, y, curAngle) {
      if (this.isSelf) {
        this.newX = this.startPos.x + x;
      } else {
        this.newX = this.startPos.x - x;
      }

      this.newY = this.originY + y;

      this.owner.x = this.newX;
      this.owner.y = this.newY;
      if (this.firstAngle == undefined) {
        this.firstAngle = this.getDegreeByPos(x, y, this.newX, this.newY);
      }
      if (this.params.weaponType != 1) {
        this.imgWeapon.rotation = this.firstAngle + curAngle;
      } else {
        this.imgWeapon.rotation = this.getDegreeByPos(x, y, this.newX, this.newY);
      }

      // 
      this.refreshWeaponPoint(this.newX, this.newY);
      if (this.newX > 1334 || this.newY > 750 || this.newX < 0) {
        this.endMove();
        return;
      }
      if (this.doPolygonsIntersect(this.weaponPoint, this.otherPlayerComp.collidePoint)) {
        // console.error(this.weaponPoint, this.otherPlayerComp.collidePoint)
        /*     let sprite=new Laya.Sprite();
            GameControl.instance.owner.addChild(sprite);
            sprite.pos(this.weaponPoint[0].x,this.weaponPoint[0].y)
            sprite.size(this.collideW,this.collideH)
            sprite.graphics.clear();
            sprite.graphics.drawRect(0,0,this.collideW,this.collideH,"yellow")
            sprite.zOrder=10000;
            sprite.rotation=this.imgWeapon.rotation */
        //如果对方闪避状态，无敌
        if (this.otherPlayerComp.dodge) {
          console.error('无敌状态');
          return;
        }
        //如果roleId=4,会20%反弹兵器。不会受到暴击。
        //let targetName=this.isSelf?'other':'self';
        if (this.otherPlayerComp.attr.roleId == 4) {
          var random = Math.ceil(Math.random() * 100);
          var reboundRate = this.selfPlayerComp.attr.skills[1].skillConfig.reboundRate;
          if (random <= reboundRate) {
            console.error('触发反弹');
            this.goBack();
            return;
          }
        }
        //如果是roleId是2
        if (this.selfPlayerComp.attr.roleId == 2) {
          console.error('我是龙儿');
          if (this.selfPlayerComp.attr.skills[1].skillType == 1) {
            var addHitRecoverMp = this.selfPlayerComp.attr.skills[1].skillConfig.addHitRecoverMp;
            this.selfPlayerComp.MPComp.changeMP(addHitRecoverMp);
          }
        }
        this.endMove();
        var skill = this.params.activeSkill;
        var skillEffect = this.params.skillEffect;
        var attackNum = this.calcAttackNum(skillEffect);
        if (skillEffect) {
          var skillConfig = skill.skillConfig,
              skillId = skill.skillId;
          this.otherPlayerComp.injuredEffect(this.params.weaponType, -attackNum);
          switch (skillId) {
            case 45 || 46:
              var arr = skillConfig.poison.split('-').map(Number);
              var time = arr[0];
              this.otherPlayerComp.poisonEffect(time * 1000, -arr[1] / time);
              break;
            //麻痹和冰冻一个效果
            case 49 || 50:
              this.otherPlayerComp.freezedEffect(skillConfig.mabi * 1000);
              break;
            case 53:
              var stealHp = skillConfig.stealHp;
              this.selfPlayerComp.hpRecoverEffect(attackNum * stealHp); //数值暂定，要算
              break;
            case 54:
              var stealMp = skillConfig.stealMp;
              this.selfPlayerComp.mpRecoverEffect(attackNum * stealMp);
              break;
            case 55:
              var recoverDown = skillConfig.recoverDown.split('-').map(Number);
              var recoverDownT = recoverDown[0],
                  recoverDownPer = recoverDown[1];
              this.otherPlayerComp.changePerMp(recoverDownT * 1000, recoverDownPer);
              break;
            case 59:
              var freezeTime = skillConfig.freeze * 1000;
              this.otherPlayerComp.freezedEffect(freezeTime);
              break;
            case 89:
              console.error('释放人物技能89,让对方内力减少100点');
              var downMP = skillConfig.downMp;
              this.otherPlayerComp.MPComp.changeMP(-downMP);
              break;
            //命中后对手晕眩2秒
            case 90:
              var dizzyT = skillConfig.dizziness * 1000;
              this.otherPlayerComp.dizzyEffect(dizzyT);
              break;
          }
        } else {
          this.otherPlayerComp.injuredEffect(this.params.weaponType, -attackNum);
        }
      }

      if (this.isSelf) {
        this.collideWithWeapon();
      }
    }
    /* 
        伤害公式=兵器攻击力*（攻击方臂力-防御方根骨）/攻击方臂力*[暴伤百分比]*[1+兵器炼器伤害加成百分比]*[1+英雄技能伤害加成百分比]*（1-防御方炼器减伤百分比）*兵器技能伤害百分比
    [暴伤百分比]=角色自身暴伤百分比+兵器技能附加暴伤百分比+兵器炼器暴伤百分比
    */

  }, {
    key: "calcAttackNum",
    value: function calcAttackNum(skillEffect) {
      var randomNum = Math.floor(Math.random() * 100 + 1);
      console.error('暴击百分比', this.selfPlayerComp.attr.calcCritProb);
      var selfAttr = this.selfPlayerComp.attr,
          otherAttr = this.otherPlayerComp.attr,
          selfStrength = selfAttr.roleStrength,
          //臂力
      roleCritHarm = selfAttr.calcCritProb,
          selfCritHarm = randomNum < roleCritHarm ? selfAttr.roleCritHarm / 100 : 1,
          otherBone = otherAttr.roleBone,
          otherStrength = otherAttr.roleStrength,
          skillHurtMulti = 1;
      if (skillEffect) {
        console.error('触发技能伤害，有莫有伤害倍数不知道');
        skillHurtMulti = this.params.activeSkill.skillConfig.hurt ? this.params.activeSkill.skillConfig.hurt : 1;
      }
      var acttackNum = Math.floor(this.weaponAttack * (selfStrength - otherBone) / otherStrength * selfCritHarm * skillHurtMulti);
      return acttackNum;
    }
    //兵器反弹

  }, {
    key: "goBack",
    value: function goBack() {
      this.isSelf = !this.isSelf;
      this.initWeaponInfo();
    }
    //根据抛物线的点求角度和计算矩形四个位置

  }, {
    key: "getDegreeByPos",
    value: function getDegreeByPos(x, y, newX, newY) {
      var ratio = 2 * this.curvature * x + this.b;
      var degree = Math.round(180 * Math.atan(ratio) / Math.PI);
      return degree;
    }
  }, {
    key: "refreshWeaponPoint",
    value: function refreshWeaponPoint(newX, newY) {
      var ratio = this.imgWeapon.rotation * Math.PI / 360;;
      this.weaponPoint = this.CalcCoord(newX, newY, this.collideW, this.collideH, ratio);
    }

    /* 
    x2 = x0+(x-x0)*cos(theta)+(y-y0)*sin(theta)
    y2 = y0-(x-x0)*sin(theta)+(y-y0)*cos(theta)
    (x0,y0) is the center around which you are rotating
    */
    //根据旋转角度求   

  }, {
    key: "CalcCoord",
    value: function CalcCoord(centerX, centerY, rw, rh, radians) {
      var x1 = -rw / 2 + centerX,
          x2 = rw / 2 + centerX,
          x3 = rw / 2 + centerX,
          x4 = -rw / 2 + centerX,
          y1 = -rh / 2 + centerY,
          y2 = -rh / 2 + centerY,
          y3 = rh / 2 + centerY,
          y4 = rh / 2 + centerY;

      var x11 = (x1 - centerX) * Math.cos(radians) - (y1 - centerY) * Math.sin(radians) + centerX,
          y11 = (x1 - centerX) * Math.sin(radians) + (y1 - centerY) * Math.cos(radians) + centerY,
          x21 = (x2 - centerX) * Math.cos(radians) - (y2 - centerY) * Math.sin(radians) + centerX,
          y21 = (x2 - centerX) * Math.sin(radians) + (y2 - centerY) * Math.cos(radians) + centerY,
          x31 = (x3 - centerX) * Math.cos(radians) - (y3 - centerY) * Math.sin(radians) + centerX,
          y31 = (x3 - centerX) * Math.sin(radians) + (y3 - centerY) * Math.cos(radians) + centerY,
          x41 = (x4 - centerX) * Math.cos(radians) - (y4 - centerY) * Math.sin(radians) + centerX,
          y41 = (x4 - centerX) * Math.sin(radians) + (y4 - centerY) * Math.cos(radians) + centerY;
      return [{
        x: Math.round(x11),
        y: Math.round(y11)
      }, {
        x: Math.round(x21),
        y: Math.round(y21)
      }, {
        x: Math.round(x31),
        y: Math.round(y31)
      }, {
        x: Math.round(x41),
        y: Math.round(y41)
      }];
    }
  }, {
    key: "collideWithWeapon",
    value: function collideWithWeapon() {
      //GameControl.instance.selfWeapons.forEach((weaponComp,index)=>{
      for (var i = 0; i < _GameControl2.default.instance.otherWeapons.length; i++) {
        var otherWeapon = _GameControl2.default.instance.otherWeapons[i];
        if (!this.effectAni && !otherWeapon.effectAni) {
          if (this.doPolygonsIntersect(this.weaponPoint, otherWeapon.weaponPoint) && this.weaponType == otherWeapon.weaponType) {
            /*   console.log(this.owner.x);
              console.log(this.weaponPoint,otherWeapon.weaponPoint)
              let sprite=new Laya.Sprite();
              GameControl.instance.owner.addChild(sprite);
              sprite.pos(this.weaponPoint[0].x,this.weaponPoint[0].y)
              sprite.size(this.collideW,this.collideH)
              sprite.graphics.clear();
              sprite.graphics.drawRect(0,0,this.collideW,this.collideH,"yellow")
              this.stopParabola();
              otherWeapon.stopParabola()
              return; */
            if (this.weaponDurable > otherWeapon.weaponDurable) {
              otherWeapon.playWeaponCollideEffect();
              this.weaponDurable -= otherWeapon.weaponDurable;
              this.owner.zOrder = 100 - this.weaponDurable;
              this.changeHP(-otherWeapon.weaponDurable);
              i -= 1;
            } else if (this.weaponDurable < otherWeapon.weaponDurable) {
              this.playWeaponCollideEffect();
              otherWeapon.weaponDurable -= this.weaponDurable;
              otherWeapon.owner.zOrder = 100 - this.weaponDurable;
              otherWeapon.changeHP(-this.weaponDurable);
              break;
              // i-=1;
            } else {
              this.playWeaponCollideEffect();
              otherWeapon.endMove();
              break;
            }

            // alert('碰撞到了')
          }
        }
        /* let ani=new Laya.Animation()
        ani.play() */
      }
      //})
    }
  }, {
    key: "playWeaponCollideEffect",
    value: function playWeaponCollideEffect() {
      var _this2 = this;

      this.boxAniWeapon.visible = true;
      this.effectAni = true;
      // this.imgWeapon.visible=false;
      //兵器上带技能的隐藏
      this.stopSkillEffect();
      this.stopParabola();
      this.tween.to(this.imgWeapon, {
        scaleX: 1.5,
        scaleY: 1.5,
        alpha: 0.3
      }, 500, Laya.Ease.linearIn, Laya.Handler.create(this, function () {
        console.log('变大效果播放完', new Date().getTime());
        _this2.endMove();
      }));
      this.boxAniCollision.play(0, false);
    }
  }, {
    key: "doPolygonsIntersect",
    value: function doPolygonsIntersect(a, b) {
      var polygons = [a, b];
      var minA, maxA, projected, i, i1, j, minB, maxB;

      for (i = 0; i < polygons.length; i++) {

        // for each polygon, look at each edge of the polygon, and determine if it separates
        // the two shapes
        var polygon = polygons[i];
        for (i1 = 0; i1 < polygon.length; i1++) {

          // grab 2 vertices to create an edge
          var i2 = (i1 + 1) % polygon.length;
          var p1 = polygon[i1];
          var p2 = polygon[i2];

          // find the line perpendicular to this edge
          var normal = {
            x: p2.y - p1.y,
            y: p1.x - p2.x
          };

          minA = maxA = undefined;
          // for each vertex in the first shape, project it onto the line perpendicular to the edge
          // and keep track of the min and max of these values
          for (j = 0; j < a.length; j++) {
            projected = normal.x * a[j].x + normal.y * a[j].y;
            if (!minA || projected < minA) {
              minA = projected;
            }
            if (!maxA || projected > maxA) {
              maxA = projected;
            }
          }

          // for each vertex in the second shape, project it onto the line perpendicular to the edge
          // and keep track of the min and max of these values
          minB = maxB = undefined;
          for (j = 0; j < b.length; j++) {
            projected = normal.x * b[j].x + normal.y * b[j].y;
            if (!minB || projected < minB) {
              minB = projected;
            }
            if (!maxB || projected > maxB) {
              maxB = projected;
            }
          }

          // if there is no overlap between the projects, the edge we are looking at separates the two
          // polygons, and we know there is no overlap
          if (maxA < minB || maxB < minA) {
            //   console.log("polygons don't intersect!");
            return false;
          }
        }
      }
      return true;
    }
  }, {
    key: "endMove",
    value: function endMove() {
      this.stopSkillEffect();
      this.stopParabola();
      this.owner.removeSelf();
      _GameControl2.default.instance.removeWeapon(this);
    }
  }, {
    key: "onDisable",
    value: function onDisable() {
      Laya.Pool.recover("weapon", this.owner);
    }
  }, {
    key: "onDestroy",
    value: function onDestroy() {}
  }]);

  return Weapon;
}(PaoYa.Component);

exports.default = Weapon;

},{"../GameControl":4}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _GameControl = require("../GameControl");

var _GameControl2 = _interopRequireDefault(_GameControl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WeaponBar = function (_PaoYa$Component) {
    _inherits(WeaponBar, _PaoYa$Component);

    /** @prop {name:spWeapon,tips:"武器图片",type:Node} */
    /** @prop {name:imgQuality,tips:"代表武器品质的背景",type:Node} */
    /** @prop {name:spShadow,tips:"阴影遮罩",type:Node} */
    /** @prop {name:imgType,tips:"武器类型图片",type:Node} */
    /** @prop {name:lblGrade,tips:"武器等级",type:Node} */
    /** @prop {name:boxAniWarn,tips:"animation box",type:Node} */
    /** @prop {name:aniWarn,tips:"冷却完发光animation",type:Node} */
    function WeaponBar() {
        _classCallCheck(this, WeaponBar);

        return _possibleConstructorReturn(this, (WeaponBar.__proto__ || Object.getPrototypeOf(WeaponBar)).call(this));
    }

    _createClass(WeaponBar, [{
        key: "onAwake",
        value: function onAwake() {
            /*   console.log("WeaponBar awake.....")
              console.log(this.owner.params); */
            // this.params=this.owner.params;

            //初始化数值。冷却时间
            var owner = this.owner;
            this.ownW = owner.width;
            this.ownH = owner.height;
            this.boxAniWarn.pos(this.ownW / 2, this.ownH / 2);
            // this.aniWarn.play(0,true)
            owner.on(Laya.Event.CLICK, this, this.clickHandler);

            this.spMask = new Laya.Sprite();
            this.maskArea = new Laya.Sprite();

            this.maskArea.texture = "remote/game/frameBg.png";

            owner.addChild(this.maskArea);
            this.maskArea.mask = this.spMask;
            this.maskArea.visible = false;

            this.maxAngle = 270;
            this.endAngle = -90;
            this.startAngle = -90;
            this.freezeing = false;

            this.cdTime = this.params.weaponCd * 1000;
            this.originCdTime = this.cdTime;

            this.weaponConsume = this.params.weaponConsume; //使用一次要消耗的体力值
            //暂时调用
            // this.setCdTime(1000)

            this.initView();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {}
        //    console.log(this.spWeapon);

        //根据武器参数，初始化视图

    }, {
        key: "initView",
        value: function initView() {
            var skin = "remote/small_weapons/s_" + this.params.weaponId + ".png";
            this.spWeapon.texture = skin;
            this.maskArea.graphics.drawTexture(Laya.loader.getRes(skin), 0, 0, this.ownW, this.ownH);
            this.imgQuality.skin = "remote/game/quality_" + this.params.weaponStar + ".png";
            this.imgType.skin = "remote/game/type_" + this.params.weaponType + ".png";
            if (this.params.weaponLevel) {
                this.lblGrade.text = "LV." + this.params.weaponLevel;
            }
        }
    }, {
        key: "onDisable",
        value: function onDisable() {}
    }, {
        key: "clickHandler",
        value: function clickHandler(e) {
            if (this.freezeing) {
                console.warn("冷却状态不接受点击");
                return;
            }
            console.error('传出去的武器攻击值:', this.params.weaponAttack);
            this.postNotification(WeaponBar.CLICK, [this]);
        }
    }, {
        key: "setCdTime",
        value: function setCdTime(cdTime) {
            console.warn('修改cd时间:', cdTime);
            //cd 时间
            this.cdTime = cdTime;
        }
    }, {
        key: "drawTexture",
        value: function drawTexture(skin) {
            this.maskArea.graphics.drawTexture(Laya.loader.getRes(skin), 0, 0, this.ownW, this.ownH);
        }
        //所谓冷却是一种障眼法

    }, {
        key: "startT",
        value: function startT(time) {
            if (this.cdTime == 0) {
                console.error('冷却免疫');
                return;
            }
            this.spShadow.visible = true;
            this.maskArea.visible = true;
            this.freezeing = true;

            this.beiginTime = new Date().getTime();

            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.ownW / 2, this.ownH / 2, this.ownW, this.startAngle, this.endAngle, "#000000");
            var cdT = time == undefined ? this.cdTime : time;

            Laya.timer.frameLoop(1, this, this.startCd, [cdT]);
        }
    }, {
        key: "startCd",
        value: function startCd(time) {
            //  console.log("时间间隔：",this.frameCd);
            if (this.endAngle >= this.maxAngle) {
                this.endCD();
                this.aniWarn.play(0, false);
                return;
            }
            this.endAngle += Laya.timer.delta * 360 / time;
            this.spMask.graphics.clear();
            this.spMask.graphics.drawPie(this.ownW / 2, this.ownH / 2, this.ownW, this.startAngle, this.endAngle, "#000000");
        }
        //暂停cd

    }, {
        key: "suspendCd",
        value: function suspendCd() {
            Laya.timer.clear(this, this.startCd);
        }
        //恢复cd

    }, {
        key: "resumeCd",
        value: function resumeCd() {
            /*  Laya.timer.loop(this.frameCd,this,this.startCd); */
        }
    }, {
        key: "endCD",
        value: function endCD() {
            Laya.timer.clearAll(this);
            this.maskArea.visible = false;
            this.spShadow.visible = false;
            this.freezeing = false;
            this.endAngle = -90;
        }
        //

    }, {
        key: "onDestroy",
        value: function onDestroy() {}
    }]);

    return WeaponBar;
}(PaoYa.Component);

exports.default = WeaponBar;

WeaponBar.CLICK = "weanponBarClick";

},{"../GameControl":4}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _LoadingView = require('./Loading/LoadingView');

var _LoadingView2 = _interopRequireDefault(_LoadingView);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var GameMain = function (_PaoYa$Main) {
	_inherits(GameMain, _PaoYa$Main);

	function GameMain() {
		_classCallCheck(this, GameMain);

		return _possibleConstructorReturn(this, (GameMain.__proto__ || Object.getPrototypeOf(GameMain)).apply(this, arguments));
	}

	_createClass(GameMain, [{
		key: 'setupOthers',
		value: function setupOthers() {}
	}, {
		key: 'setupConfig',
		value: function setupConfig() {
			var resList = [];
			/**添加必要网络资源 */
			/* [
   ].forEach(url => {
   	resList.push(`${PaoYa.DataCenter.CDNURL}${url}`)
   }) */

			/**加载必要首屏界面资源 */
			/* 	let scenes = [
   		
   	]
   	resList = resList.concat(scenes) */
			/**加载游戏界面所需资源 */
			//resList = resList.concat(this.setupGameRes())

			PaoYa.DataCenter.GAMERES = this.setupGameRes();
			//分享地址
			PaoYa.ShareManager.makeShareImageURLHandler = function () {
				return PaoYa.DataCenter.CDNURL + PaoYa.DataCenter.config.game.share_img.randomItem;
			};
		}
	}, {
		key: 'setupLoadingView',
		value: function setupLoadingView(cb) {
			Laya.Scene.load('scenes/common/Loading/LoadWaitingView.scene', Laya.Handler.create(this, function (scene) {
				PaoYa.Navigator.adjustViewPosition(scene);
				Laya.Scene.setLoadingPage(scene);
				Laya.AtlasInfoManager.enable('fileconfig.json', Laya.Handler.create(this, cb));
			}));
		}
	}, {
		key: 'initRootScene',
		value: function initRootScene(launchInfo, isFirstLaunch) {
			PaoYa.ShareManager.isShare = false;
			this.navigator.push("HomeView", {}, null, Laya.Handler.create(this, function () {}), null);
		}
	}, {
		key: 'onHide',
		value: function onHide(res) {
			if (PaoYa.ShareManager.isShare) {
				return;
			}
			if (PaoYa.navigator.visibleScene.url.indexOf('FBView') >= 0) {
				console.warn("在邀请界面");
				return;
			}
			if (res && res.mode != undefined && res.targetAction != undefined && !(res.mode == "hide" && res.targetAction == 8)) {
				this.socket.sendMessage(PaoYa.Client.LEAVE_ROOM, {});
				Laya.Dialog.manager.closeAll();
				this.navigator.popToRootScene();
			}
		}
	}]);

	return GameMain;
}(PaoYa.Main);

exports.default = GameMain;

},{"./Loading/LoadingView":20}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HomeControl = function (_PaoYa$Component) {
    _inherits(HomeControl, _PaoYa$Component);

    function HomeControl() {
        _classCallCheck(this, HomeControl);

        return _possibleConstructorReturn(this, (HomeControl.__proto__ || Object.getPrototypeOf(HomeControl)).apply(this, arguments));
    }

    _createClass(HomeControl, [{
        key: "onAwake",
        value: function onAwake() {}
    }, {
        key: "onAppear",
        value: function onAppear() {}
    }, {
        key: "onClick",
        value: function onClick(e) {
            var _this2 = this;

            switch (e.target.name) {
                //兵器库
                case "btnWeaponHouse":
                    console.log("进入兵器库");
                    break;
                //兵器商店
                case "btnWeaponStore":
                    console.log("进入兵器商店");
                    break;
                //兵器谱
                case "btnWeaponSpectrum":
                    console.log("进入兵器谱");
                    break;
                //英雄库
                case "btnHerosHouse":
                    console.log("进入英雄库");
                    break;

                //签到
                case "btnRegister":
                    console.log("打开签到");
                    break;
                //抽奖转盘
                case "btnRoulette":
                    console.log("去抽奖");
                    break;
                //开始游戏：
                case "btnStartGame":
                    console.log("开始游戏请求的数据......");
                    this.POST("hero_game_start", { stageId: 1 }, function (res) {
                        //console.log(res)
                        _this2.navigator.push("GameView", res);
                    });
                    // this.navigator.push("GameView",PaoYa.DataCenter.config)
                    break;
                //华山论剑
                case "btnBattle":
                    console.log("华山论剑");
                    break;
                //决战紫禁城之巅
                case "btnBoss":
                    console.log("决战");
                    break;
                //排行榜
                case "rank":
                    console.log("进入排行榜");
                    break;
                //玩法
                case "btnPlayRule":
                    console.log("玩法介绍");
                    break;
                //设置
                case "btnSet":
                    console.log("设置");
                    break;

            }
        }
    }, {
        key: "onDisappear",
        value: function onDisappear() {}
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "onDisable",
        value: function onDisable() {}
    }, {
        key: "onDestroy",
        value: function onDestroy() {}
    }]);

    return HomeControl;
}(PaoYa.Component);

exports.default = HomeControl;

},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoadingControl = function (_PaoYa$Component) {
    _inherits(LoadingControl, _PaoYa$Component);

    function LoadingControl() {
        _classCallCheck(this, LoadingControl);

        return _possibleConstructorReturn(this, (LoadingControl.__proto__ || Object.getPrototypeOf(LoadingControl)).apply(this, arguments));
    }

    _createClass(LoadingControl, [{
        key: 'onAwake',

        /** @prop {name:progressView,tips:'',type:Node} */
        /** @prop {name:lblProgress,tips:'',type:Node} */
        /** @prop {name:progressViewBg,tips:'',type:Node} */
        /** @prop {name:type,type:Option,option:"normal,waiting",default:normal}*/
        value: function onAwake() {
            this.type = this.type || 'normal';
            this.owner.on(Laya.Event.PROGRESS, this, this.onProgress);
            if (this.type !== 'normal') {
                var bg = this.progressViewBg;
                bg.graphics.clear();
                bg.graphics.drawPath(0, 0, PaoYa.Utils.makeAllCornerRoundRectPath(bg.width, bg.height, 20), {
                    fillStyle: "#000000"
                });
            }
        }
    }, {
        key: 'onUpdate',
        value: function onUpdate() {
            if (this.type !== 'normal') {
                this.progressView.rotation += 5;
            }
        }
    }, {
        key: 'onProgress',
        value: function onProgress(progress) {
            this.lblProgress.text = Math.ceil(progress * 100) + '%';
            if (this.type == 'normal') {
                var mask = this.progressView.mask;
                mask.graphics.clear();
                mask.graphics.drawRect(0, 0, Math.ceil(this.progressView.width * progress), this.progressView.height, '#ff0000');
            }
        }
    }]);

    return LoadingControl;
}(PaoYa.Component);

exports.default = LoadingControl;

},{}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LoadingView = function (_PaoYa$View) {
    _inherits(LoadingView, _PaoYa$View);

    function LoadingView(type) {
        _classCallCheck(this, LoadingView);

        var _this = _possibleConstructorReturn(this, (LoadingView.__proto__ || Object.getPrototypeOf(LoadingView)).call(this));

        _this.type = type || 'normal';
        _this.on(Laya.Event.PROGRESS, _this, _this.onProgress);
        if (_this.type !== 'normal') {
            Laya.timer.frameLoop(1, _this, _this.onUpdate);
        }
        //on QQ
        var scene = PaoYa.game.launchOption.scene;
        if (window.BK && (scene == 318 || scene == 319) && _this.type == 'normal') {
            _this.lblProgress.visible = false;
            _this.progressView.visible = false;
            _this.imgProgressBg.visible = false;
            _this.lblTips.visible = false;
        }
        return _this;
    }

    _createClass(LoadingView, [{
        key: 'onUpdate',
        value: function onUpdate() {
            if (this.type !== 'normal') {
                this.progressView.rotation += 5;
            }
        }
    }, {
        key: 'onProgress',
        value: function onProgress(progress) {
            this.lblProgress.text = Math.ceil(progress * 100) + '%';
            if (this.type == 'normal') {
                var mask = this.progressView.mask;
                mask.graphics.clear();
                mask.graphics.drawRect(0, 0, Math.ceil(this.progressView.width * progress), this.progressView.height, '#ff0000');
            }
        }
    }]);

    return LoadingView;
}(PaoYa.View);

exports.default = LoadingView;

},{}]},{},[3]);
